1. Token Management (token/token.go)

package token

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"github.com/jumayevgadaym/tsu-toleg/internal/config"
	"github.com/jumayevgadaym/tsu-toleg/internal/infrastructure/cache"
	"github.com/jumayevgadaym/tsu-toleg/pkg/errlst"
)

// TokenOps handles token generation, parsing, and storage.
type TokenOps struct {
	cfg        config.JWTOps
	redisStore cache.Store
}

// NewTokenOps creates a new TokenOps instance.
func NewTokenOps(cfg config.JWTOps, redisStore cache.Store) *TokenOps {
	return &TokenOps{cfg: cfg, redisStore: redisStore}
}

// GenerateTokens generates access and refresh tokens.
func (t *TokenOps) GenerateTokens(userID string, roleID int) (accessToken, refreshToken string, err error) {
	// Access Token
	accessClaims := jwt.MapClaims{}
	accessClaims["user_id"] = userID
	accessClaims["role_id"] = roleID
	accessClaims["exp"] = time.Now().Add(time.Minute * time.Duration(t.cfg.AccessTokenExpirationMinutes)).Unix() // Short-lived

	accessT := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
	accessToken, err = accessT.SignedString([]byte(t.cfg.AccessTokenSecret))
	if err != nil {
		return "", "", fmt.Errorf("generating access token: %w", err)
	}

	// Refresh Token (long-lived, UUID recommended)
	refreshToken = uuid.New().String()  // Or another secure random string generator
	err = t.StoreRefreshToken(context.Background(), refreshToken, userID)
	if err != nil {
		return "", "", fmt.Errorf("storing refresh token: %w", err)
	}

	return
}

// ParseAccessToken parses and validates an access token.
func (t *TokenOps) ParseAccessToken(tokenString string) (*jwt.MapClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(t.cfg.AccessTokenSecret), nil
	})
	if err != nil {
		return nil, errlst.NewUnauthorizedError("invalid access token: " + err.Error()) // More specific error message
	}

	if claims, ok := token.Claims.(*jwt.MapClaims); ok && token.Valid {
		return claims, nil
	}
	return nil, errlst.NewUnauthorizedError("invalid access token")
}

func (t *TokenOps) StoreRefreshToken(ctx context.Context, token string, userID string) error {
	expiration, err := strconv.Atoi(os.Getenv("REFRESH_TOKEN_EXP"))
	if err != nil {
		return errlst.NewInternalServerError("invalid refresh token expiration")
	}

	err = t.redisStore.Set(ctx, token, userID, time.Duration(expiration)*time.Hour*24) // Use days for refresh token expiration
	if err != nil {
		return errlst.NewInternalServerError("failed to store refresh token in Redis: " + err.Error()) // More specific error message
	}
	return nil
}

// FetchRefreshToken retrieves a refresh token from Redis.
func (t *TokenOps) FetchRefreshToken(ctx context.Context, token string) (string, error) {
	userID, err := t.redisStore.Get(ctx, token)
	if err != nil {
		if err == cache.ErrNotFound {
			return "", errlst.NewUnauthorizedError("invalid or expired refresh token") // More specific error
		}
		return "", errlst.NewInternalServerError("failed to fetch refresh token from Redis: " + err.Error()) // More specific error
	}
	return userID, nil
}

// DeleteRefreshToken removes a refresh token from Redis.
func (t *TokenOps) DeleteRefreshToken(ctx context.Context, token string) error {
	err := t.redisStore.Delete(ctx, token)
	if err != nil {
		return errlst.NewInternalServerError("failed to delete refresh token from Redis: " + err.Error()) // More specific error
	}
	return nil
}

// ... other token-related functions ...
Use code with caution.
Go
2. Cookie Utilities (pkg/utils/cookies.go)

package utils

import (
	"os"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/jumayevgadaym/tsu-toleg/internal/config"
)

func SetAuthCookies(c *fiber.Ctx, cfg *config.Config, accessToken, refreshToken string) {
	setCookie(c, os.Getenv("ACCESS_TOKEN_NAME"), accessToken, cfg.JWT.AccessTokenExpirationMinutes)    // Short-lived
	setCookie(c, os.Getenv("REFRESH_TOKEN_NAME"), refreshToken, cfg.JWT.RefreshTokenExpirationDays*24*60) // Long-lived
}

// ClearAuthCookies clears authentication cookies.
func ClearAuthCookies(c *fiber.Ctx) {
	clearCookie(c, os.Getenv("ACCESS_TOKEN_NAME"))
	clearCookie(c, os.Getenv("REFRESH_TOKEN_NAME"))
}

func setCookie(c *fiber.Ctx, name, value string, minutes int) {
	expirationTime := time.Now().Add(time.Minute * time.Duration(minutes))
	c.Cookie(&fiber.Cookie{
		Name:     name,
		Value:    value,
		Expires:  expirationTime,
		HTTPOnly: true,
		Secure:   config.IsProd(),        // Secure in production
		SameSite: fiber.CookieSameSiteLaxMode, // Adjust SameSite as needed
		Path:     "/",                  // Important for logout to work correctly
	})
}

func clearCookie(c *fiber.Ctx, name string) {
	c.Cookie(&fiber.Cookie{
		Name:     name,
		Value:    "",
		Expires:  time.Now().Add(-time.Hour), // Expire in the past
		HTTPOnly: true,
		Secure:   config.IsProd(),
		SameSite: fiber.CookieSameSiteLaxMode,
		Path:     "/", // Important for logout to work correctly
	})
}
Use code with caution.
Go
3. Middleware (middleware/role.go)

package middleware

// ... (imports) ...

func RoleBasedMiddleware(tokenOps *token.TokenOps, allowedRoles ...int) fiber.Handler {
    return func(c *fiber.Ctx) error {
        accessToken := c.Cookies(os.Getenv("ACCESS_TOKEN_NAME"))
        refreshToken := c.Cookies(os.Getenv("REFRESH_TOKEN_NAME"))

        if accessToken == "" {
            if refreshToken == "" {
                return errlst.NewUnauthorizedError("missing access and refresh tokens")
            }

            newAccessToken, err := handleRefreshToken(c.Context(), tokenOps, refreshToken, c)

            if err != nil {
                return err
            }

            accessToken = newAccessToken
        }

        claims, err := tokenOps.ParseAccessToken(accessToken)
        if err != nil {

            return errlst.Response(c, err)
        }

		// ... (role checking logic using claims["role_id"])
    }
}

func handleRefreshToken(ctx context.Context, tokenOps *token.TokenOps, refreshToken string, c *fiber.Ctx) (string, error) {
	userID, err := tokenOps.FetchRefreshToken(ctx, refreshToken)

	if err != nil {
		return "", err
	}

	claims, ok := c.Locals("user_claims").(*jwt.MapClaims)

	if !ok {
		return "", errlst.NewInternalServerError("failed to get role id")
	}

	roleID := int((*claims)["role_id"].(float64))

	newAccessToken, newRefreshToken, err := tokenOps.GenerateTokens(userID, roleID)

	if err != nil {
		return "", err
	}

	utils.SetAuthCookies(c, config.Get(), newAccessToken, newRefreshToken)

	err = tokenOps.DeleteRefreshToken(ctx, refreshToken)
	if err != nil {

	}

	return newAccessToken, nil
}

Date: Wed, 27 Nov 2024 16:35:18 GMT
Content-Type: application/json
Content-Length: 538
Set-Cookie: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4LCJyb2xlX2lkIjoyLCJ1c2VybmFtZSI6ImJiYmJiYiIsImV4cCI6MTczMjgxMTcxOH0.ysDOfQWq05hR-TkOkNFdGc_PgKGASDY_ApP8t01U0VQ; expires=Thu, 28 Nov 2024 16:35:18 GMT; path=/; HttpOnly; SameSite=Lax